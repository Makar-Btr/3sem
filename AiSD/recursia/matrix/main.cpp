/*Дана последовательность из s матриц A1, A2, …, As. Требуется определить, в
каком порядке их следует перемножать, чтобы число атомарных операций умножения
было минимальным. Матрицы предполагаются совместимыми по отношению к матричному
умножению (т. е. число столбцов матрицы Ai − 1 совпадает с числом строк матрицы
Ai).

Будем считать, что произведение матриц — операция, которая принимает на вход две
матрицы размера k × m и m × n и возвращает матрицу размера k × n, затратив на
это kmn атомарных операций умножения. (Базовый тип позволяет хранить любой
элемент итоговой и любой возможной промежуточной матрицы, поэтому умножение двух
элементов требует одной атомарной операции.)

Так как перемножение матриц ассоциативно, итоговая матрица не зависит от порядка
выполнения операций умножения. Другими словами, нет разницы, в каком порядке
расставляются скобки между множителями, результат будет один и тот же.

Input
В первой строке задано число s матриц (2 ≤ s ≤ 100). В последующих s строках
заданы размеры матриц: строка i + 1 содержит через пробел число ni строк и число
mi столбцов матрицы Ai (1 ≤ ni, mi ≤ 100). Гарантируется, что mi совпадает с
ni + 1 для всех индексов i от 1 до s − 1.

Output
Выведите минимальное число атомарных операций умножения, необходимое для
перемножения s матриц.*/

#include <fstream>
#include <vector>

using namespace std;

int main()
{
    ifstream in("input.txt");
    ofstream out("output.txt");

    int s, n, m;

    in >> s;

    vector<int> sizes(s + 1, 0);
    for (int i = 0; i < s; i++)
    {
        in >> n >> m;
        if (i == 0)
        {
            sizes[i] = n;
        }
        sizes[i + 1] = m;
    }

    vector<vector<long long>> costs(s + 1, vector<long long>(s + 1, 0));

    int j;
    long long cost = 0;
    for (int l = 2; l <= s; l++)
    {
        for (int i = 1; i <= s - l + 1; i++)
        {
            j = i + l - 1;
            costs[i][j] = LLONG_MAX;
            for (int k = i; k < j; k++)
            {
                cost = costs[i][k] + costs[k + 1][j] +
                       (long long)(sizes[i - 1] * sizes[k] * sizes[j]);
                if (cost < costs[i][j])
                {
                    costs[i][j] = cost;
                }
            }
        }
    }

    out << costs[1][s];
    return 0;
}