/*Очень большая корпорация решила разработать свою собственную сеть. Вначале
каждое из n предприятий этой корпорации, пронумерованных целыми числами от 1 до
n, имеет свой вычислительный и телекоммуникационный центр.

Для повышения качества сервиса корпорация начала собирать некоторые предприятия
в кластеры, каждый из которых обслуживается одним телекоммуникационным центром.
Для этой цели корпорация выбирает один из существующих центров (пусть это будет
центр i, который обслуживает кластер A) и одно из предприятий j, находящееся в
каком-то другом кластере B (j не обязательно является центром). Затем i и j
связываются телекоммуникационной линией. Длина линии между предприятиями i и j
вычисляется по формуле |i − j| mod 1000. Таким образом, два старых кластера
объединяются в один новый, причём телекоммуникационным центром нового кластера
объявляется телекоммуникационный центр кластера B.

Если телекоммуникационный сервер j обслуживает кластер A и предприятие i
находится в кластере A, то будем говорить, что j является обслуживающим центром
для i.

Но, к сожалению, после каждого такого объединения длина телекоммуникационной
линии между предприятием и обслуживающим его центром может меняться, и
руководство корпорации хочет знать эту длину. Напишите программу, которая
позволила бы корпорации узнавать расстояния от предприятия до центра в любой
момент времени.

Input
Первая строка содержит число n предприятий (4 ≤ n ≤ 200 000).
Следующие строки описывают команды, подаваемые корпорацией. Число команд не
превосходит 200 000.

Формат команд:

E: i — запрос длины пути между предприятием i и обслуживающим его
телекоммуникационным центром;
I: i j — информирует о том, что обслуживающий центр
i присоединяется к предприятию j;
O: — говорит о том, что корпорация заканчивает
свои команды (конец входных данных).
Output
Выведите по одной строке на каждую команду E во входных данных. Каждая такая
строка должна содержать единственное число — запрашиваемую длину между
предприятием и обслуживающим его телекоммуникационным центром.*/

#include <fstream>
#include <vector>

using namespace std;

class DSU
{
  public:
    DSU(int n)
    {
        m_parent.resize(n + 1);
        m_dist.resize(n + 1);
        for (int i = 0; i <= n; i++)
        {
            m_parent[i] = i;
            m_dist[i] = 0;
        }
    }

    int FindSet(int x)
    {
        if (m_parent[x] == x)
        {
            return x;
        }

        int root = x;
        vector<int> m_path;
        while (m_parent[root] != root)
        {
            m_path.push_back(root);
            root = m_parent[root];
        }

        for (int i = m_path.size() - 1; i >= 0; i--)
        {
            int node = m_path[i];
            int old_parent = m_parent[node];

            m_dist[node] += m_dist[old_parent];

            m_parent[node] = root;
        }

        return root;
    }

    void Union(int i, int j)
    {
        m_parent[i] = j;

        m_dist[i] = abs(i - j) % 1000;
    }

    long long GetDist(int x)
    {
        FindSet(x);
        return m_dist[x];
    }

  private:
    vector<int> m_parent;
    vector<long long> m_dist;
};

class Graph
{
  public:
    Graph(int n) : m_graph(n) {}

    void I(int i, int j) { m_graph.Union(i, j); }

    long long E(int i) { return m_graph.GetDist(i); }

  private:
    DSU m_graph;
};

int main()
{
    ios_base::sync_with_stdio(false);

    ifstream fin("input.txt");
    ofstream fout("output.txt");

    int n;
    if (!(fin >> n))
        return 0;

    Graph graph(n);

    char command;
    int i, j;
    while (fin >> command)
    {
        if (command == 'O')
            break;

        switch (command)
        {
        case 'E':
        {
            fin >> i;
            fout << graph.E(i) << endl;
            break;
        }
        case 'I':
        {
            fin >> i >> j;
            graph.I(i, j);
            break;
        }
        default:
            break;
        }
    }
    return 0;
}