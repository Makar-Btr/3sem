/*Кодирование Хаффмана (D. A. Huffman) относится к префиксному кодированию,
позволяющему минимизировать длину текста за счёт того, что различные символы
кодируются различным числом битов.

Напомним процесс построения кода. Вначале строится дерево кода Хаффмана. Пусть
исходный алфавит состоит из $n$ символов, $i$-й из которых встречается $p_i$ раз
во входном тексте. Изначально все символы считаются активными вершинами будущего
дерева, $i$-я вершина помечена значением $p_i$. На каждом шаге мы берём две
активных вершины с наименьшими метками, создаём новую вершину, помечая её суммой
меток этих вершин, и делаем её их родителем. Новая вершина становится активной,
а двое её сыновей из списка активных вершин удаляются. Процесс многократно
повторяется, пока не останется только одна активная вершина, которая полагается
корнем дерева.

Заметим, что символы алфавита представлены листьями этого дерева. Для каждого
листа (символа) длина его кода Хаффмана равна длине пути от корня дерева до
него. Сам код строится следующим образом: для каждой внутренней вершины дерева
рассмотрим две дуги, идущие от неё к сыновьям. Одной из дуг присвоим метку $0$,
другой — $1$. Код каждого символа — последовательность из нулей и единиц на пути
от корня к листу.

Задача состоит в том, чтобы вычислить длину текста после его кодирования методом
Хаффмана. Сам текст не дан, известно лишь, сколько раз каждый символ встречается
в тексте. Этого достаточно для решения задачи, поскольку длина кода зависит
только от частоты появления символов.

Разработайте алгоритм, работающий за n, где n - количество частот появления
символов.

Input
Первая строка содержит целое число $n$ ($2 \le n \le 2\, 500\,000$).Вторая
строка содержит $n$ чисел $p_i$ — частоты появления символов в тексте ($1 \le
p_i \le 10^9$, $p_i \le p_{i+1}$ для каждого $i$ от $1$ до $n-1$).

Output
Выведите единственное число — длину (в битах) закодированного текста.*/

#include <fstream>
#include <vector>

using namespace std;

long long Min(vector<long long> &frequencies, vector<long long> &nodes, int &i,
              int &j)
{
    if (i >= frequencies.size())
    {
        return nodes[j++];
    }
    else if (j >= nodes.size())
    {
        return frequencies[i++];
    }
    else if (frequencies[i] < nodes[j])
    {
        return frequencies[i++];
    }
    else
    {
        return nodes[j++];
    }
}

int main()
{
    ifstream fin("huffman.in");
    ofstream fout("huffman.out");

    int size;
    fin >> size;

    vector<long long> frequencies(size), nodes;
    for (int i = 0; i < size; ++i)
    {
        fin >> frequencies[i];
    }

    int i = 0, j = 0;
    long long result = 0;

    long long u, v;
    while (size-- > 1)
    {
        u = Min(frequencies, nodes, i, j);
        v = Min(frequencies, nodes, i, j);
        result += u + v;
        nodes.push_back(u + v);
    }

    fout << result << endl;

    return 0;
}